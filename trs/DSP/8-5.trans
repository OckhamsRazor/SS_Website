ok 我們接下去
我們剛才在講的情形就是
我的第一個word 就是一顆tree
這顆tree 就後面就有六萬個
第一個word 我就就這個這個非常大的tree 的hidden markov model
那麼走到最後有六萬個
然後之後呢那每一個走完之後應該都要再接一個
都要再接一個
所以你就接很多
這是第二個word 就有六第二個word 其實就有六萬個這個tree 在這裡喔等等
那在這個情形之下我整個的viterbi 會變成非常複雜的viterbi
不是我們原來單獨的這一個
不是單不是單獨這這一個這樣子走而已
而變成是我一路這樣子散開來一路散開來變成很大很大
那為了要讓這個比較清楚得來講我們怎麼來做這件事情
所以底下呢用用一些這個符號把它們specify 清楚它們是什麼
這講起來是蠻複雜的
不過事實上其實你如果對於我們原來所講的那個viterbi 了解的話其實是一樣的
好那我們第一個現在現在比較複雜所以我們一堆東西
第一個呢就是我要define 清楚我這是什麼這個是什麼
這個其實就是我們原來viterbi 裡面所說的那個東西
只不過現在變複雜了所以符號變多了而已
我們原來viterbi 不是這樣
當我走到時間t 在state i 的時候
我這邊所define 的一個東西叫做delta t 的i
就是走到這裡為止的一條有最高機率的path
它的機率就是這個東西
那這個東西其實就是我現在的這個東西
是一樣的東西
這個東西其實就是這個
只不過我現在的東西變複雜了所以我現在東西變一堆符號喔
那這個意思還是一樣
那我現在變成是怎樣呢你可以看到是
我在我在時間t 的時候
在state q k 啊 q t of the word w
那當我走過來走到這段是一個word w
譬如說這裡我是一堆state
那麼這一堆這個這是一個word w
那這個word w 是是我們剛才在這個一路這樣跑下來的中間的某一段嘛
譬如說我在這裡的時候從這裡跑到這裡的這條是一個word w 對不對
因為這個我從這個tree 的頭一直走到tree 的尾的時候這是某一個word
如果到這邊發現走到這邊發現這個word 是w 的話就表示說這整個path 是w
那這個w 中間會有一堆 是一堆phone 一堆state 走起來的
那這個呢就是這個
如果這樣的話呢我在時間t 的時候
停在某一個時間t 的時候停在某一個state
這個state 叫做q t
這個q t 是屬於word w 的到這裡為 止的這個分數
那麼我一路走過來
走到這裡的這個分數
就是這邊的這個 d
這個d 的這個什麼t q t w 就是這個東西
ok 其實是一樣的
那為為什麼這個w 那這邊還有什麼因為我從頭走過來嘛
我可能從從前面走走第一個tree 走第二個tree 這樣走走到這邊
這是某一個w 嘛喔
所以這是走到路的這個path 整個path 中間的某一個w 而言
在這個w 裡面的某一個state q t
我在時間t 的時候我剛好停在這裡的這個分數喔
那麼就是所以這個其實是跟跟這個意思是一樣
只是我現在比較複雜而已
那所謂的 object function 其實也就是這個東西
也就是這個一路走過來最高的機率就是所謂object function
那我就是要optimize 這個東西
我要maximize 它嘛
那麼這個呃那是什麼是best partial path any at time t is state q t for the word w
也就是說這邊有有千千萬萬個path 走過來
但是我現在講的是到這裡為止
最好的那一個
那就相當於viterbi 裡面到這裡為止最好的那一個這樣的意思
那我都是以某一個時間來算的
所以呢是時間t 的時候來算的
那你記得viterbi 裡面很重要的一件事情是做什麼back track
因為你每一次得到這個之後下一個的時候呢
我下一個state 當t 加一的時候
它可以從這上面的任何一點跳過來
depends on 誰過來的那條path 最大
那你很可能發現結果是從這一點跳到這邊的時候機率是最大的
所以結果呢
你要把到這裡為止最好的path 就變成是這一條了
對不對這是viterbi 的基本精神嘛
所以呢你你要算t 加一的時候
你得要在算從 t 的時候所有的state 都會過來的
然後看誰最大
最後最大的是這一條的話呢
你到這邊為止最大的就變成這一條了不是它了
那因此呢我我到這邊的時候我一定要記得說
哦剛才是從這裡來的
所以這是所謂的back 這是back track 的那個pointer
我要我要說ok 它是從這兒來的
這樣我一路要記得它的前一個是哪裡
那這個是viterbi 裡面很重要一件事情你要能夠記得
你剛才從你的最佳這點是從哪裡來的
這是所謂back track pointer
那我這邊也一樣也要
那就用這個符號來代表
就是說你如果是在你的這個這個你的partial path
你你的這個best partial path end 在time t in state q t for word w 跟剛才一樣
那你如果現在是在這裡的話
那你要算剛才是哪裡來的
剛才如果是在t 減一的時候
如果是這裡來的話
那你要把這個記下來說哦剛才是從這裡來的
那個那記下來的這件事情就是就是這邊的這個h
好我就記就是就是這個back track pointer
所以這個事情跟我們講的viterbi 是完全一樣的
只是說我現在要這個變得很複雜而已
好當這個沒問題之後呢
底下的這兩件事情其實說穿了也很簡單
也跟viterbi 這邊所想的事情是完全一樣的
那只是呢我現在變得複雜了
那我們要弄清楚
現在有兩種狀況
一個叫做 intra word transition
一個叫inter word transition
什麼是intra word 就是在一個word 裡面
也就是在一個tree 裡面
這是h m m only
沒有language model
當我在這裡面走的時候
當我在這一棵 tree 裡面走的時候
我是在這裡面這條路上走
那這條路其實你可以想像
最後就是一個word
是這六萬個word 裡面的一個word
那在這個word 上面走的話呢
我其實是走一個相當長的h m m 而已嘛
所以呢它是在其實就是在走h m m 的viterbi
因此呢這裡面的東西
跟這裡面這個東西
其實就是我們原來講的viterbi 這件事情是一樣的
這是h m m only
那在這個是後沒有 language model 的事情發生因為它是在算一個word
那底下呢
什麼是inter word transition 呢
是在當你這個走完我走下一個的時候
當你這個走完我要再走下一個的時候
那你你從這個跳到下一個去的時候呢
那這個時候我我是在一個h m m 跳到另外h m m
這時候中間有什麼有language model 分數要加進來
所以呢所以呢底下是所謂inter word
是這個這個時候是language model 分數要加進來
但是我我不是在h m m 裡面是在h m m 的外面
所以呢其實很簡單就是上面是跑h m m 沒有language model
底下是跑language model 沒有h m m
好那我們分別看一下這兩個情形
那就這個而言
它在說的事情其實我們先說 h m m only
也就是在intra word 裡面
也就是在一棵tree 裡面
一棵 tree 裡面的某一條path 上面的h m m
你在上面走的時候其實這個走的事情
就是在這邊走這段word
就是在走這段嘛
那走這段的情形跟這邊是完全一樣的
跟我們從前說的其實是完全一樣的
所以這個式子其實也就是我們從前講的那個式子
只不過現在看起來比較複雜一點而已
你看我要算時間t 在q t
時間t 在q t 怎麼算
我就先算t 減一的嘛
算算這個在t 減一的時候掉在q 的t 減一的時候
在這個word 裡面我現在都在這個word 裡面嘛
我是intra word 在這個word 裡面
所以呢我在t 減一的時候
我是在q 的t 減一state
對不對所以呢我在這個t 減一的時候
還是在word w 裡面的q 的t 減一的state
在這個q 的t t 減一的時候
在q 的t 減一的那個 state
上面我也有一個最高的分數
就是那個分數然後呢再加上跳過來的分數
跳過來分數有兩個
在我們當時講viterbi 的時候呢
那兩個是什麼一個是a i j
一個是b j 的o t
你如果記得我們是有這兩個東西
a i j 告訴我從這個跳到這個機率是多少
那b j 的o t 是我現在要把現在把這個新的vector
放進來放到這個state 來ok
所以就是這兩個分數
那這兩個其實就是這裡的這兩個
就是這個東西就分成這兩個這兩個就是這個
所以呢對不對就也就是說你現在從這裡的時候
我現在要算如果說這個是 t 這個是t 加一的這是t 這是t 減一的話
我現在在t 的分數是要所有的t 減一的
都有可能跳過來看誰最大
所以所有的t 減一跳過來有有兩種
一個是a i j
每一個跳過來都有個a i j
一個呢是我要把這個b 把這個o t
放到這個新的state 裡面去
這是這是state j b j 的o t
我要把這個放進來
那現在這兩個機率其實也就是我們這邊講的這兩個機率
所以你看到譬如說這個是什麼這就是a i j 嘛
這就是在word w 裡面
然後我從q t 減一跳到q t 的機率
所以這個東西其實就是a i j
就是從這邊跳到這邊的機率就是a i j
那這個是什麼呢
這個其實就是b j 的o t
因為你你你現在就是這個啊
它就是我在這個word 裡面那麼我現在是這個o t
我看到的這個第t 個 feature vector
第t 個vector 掉在q t 的機率
那其實就是這個東西喔
那你現在把這兩個它現在是寫log 用加的啦
那意思是一樣啦就是你這兩個加起來的這個
就是說就是這個這一項嘛
就是我從t q t 減一在時間從t 減一到t 的時候
我state 從t 減一到 t 的時候
那麼我要加進去的機率是這個
那然後呢因此呢我現在在算t 的時候
就是把t 減一的所有可能的q t 減一通通加起來嗯通通看起來誰最大
就跟這邊是一樣的嘛
你你現在要算t 的時候
你就把t 減一的看看是從這過來的還是從這過來從這過來看看是誰的最大
你就算那一個最大的那嘛
那那這邊其實也是完全一樣啊我現在就是把這個嗯我現在d 的t
q t 的話呢是什麼呢
就是在t 減一的時候的所有可能的q t 減一
那這邊所有可能的q t 減一在這裡
這邊所有可能在這裡就就是等於這邊的所有可能一樣的
這邊所有可能在這裡
那所有q t 減一都有一個最大的最佳的分數
再加上跳過來的時候可能的
然後加起來之後呢我在所有的q t 減一裡面看誰最大
然後知道ok 我就是從那裡過來
所以跟這個是完全一樣的情形
然後呢我現在就找到那個最大之後我就把我就得到一個下一條path
就最大的path
因此呢這邊所說的事情
跟我們原來所說的 h m m 是完全一樣的喔
只是現在整個整個變成複雜而已
其實精神是完全相同的
那底下這個式子只是在說
那我要做這個back track
我要記得從哪過來
所以剛才的maximum
倒底是誰是q t 減一
剛才是從哪一個過來的我要記得
我就把那個剛才過來那個記下來
這就是我的back track pointer
那麼說明這個我的q bar
就是指我的t 減一的時候如果現在t t 在q t 的話
那麼t 減一是從哪個state 是在哪個state
我把那個記下來
就是剛才那個裡面的maximum 的q t 減一是哪一個
把它記下來
然後然後把它放在那個back track pointer 裡面
於是我就記得剛才是從這樣過來的
好就這樣子而已
所以這個說穿了沒什麼特別符號變複雜而已
那麼其實講的就是這件事情
就是這件事情是完全一樣的
這是intra word transition
所以這個沒什麼不同
跟我們之前講的一樣
不同的是底下這個
因為我現在還會從一棵tree 接掉接到下一棵tree 去
當我從這棵tree 接到下一棵tree 的時候會怎樣呢
那就是做了一個inter word 的transition
從這個word 跳到下一個word
那這個時候呢我們假設說
現在這個word 走完了叫做v
v 是一個word
然後呢q f 的v 是它的final state
畫清楚一點
我現在走完了這一個這個word 叫做v
它有好多state
然後它一直到最後
這是它的最後一個state
這是它的q f 的v
就是 v 的這個word
q f v 是v 的word 的這個final state
然後我現在要從這裡開始接下一棵tree
怎麼接法呢
我先增加一個空的state 叫做q
q 是一個空的state
沒有裡面沒有任何東西只是為了接方便起見
為了是要接底下這棵tree
所以q 底下呢就接底下這棵tree 出來
那這棵tree 底下會有會有這個六萬個word
所以呢我現在的這個那如果後面這個後面這個word 呢
叫做w 好
所以呢我現在這裡的這裡有六萬個word
不過每一個word 我們都叫它w
所以呢這個我這個v
v 現在這個word 走完了
到了最後final state
了那我現在要開始接下一個tree 了
那下個 tree 有六萬個可能我們叫它是w
那麼開始的時候我有一個pseudo initial state
這是一個空的state 只是為了串接方便起見叫做q
那麼如果是這樣的話呢
好我現在就有一個空的 state 在這裡
這是我的 v 的final state 接下去
那麼因此呢我現在這個這個低的這個分數啊我就先給它跳到這裡面
跳到q 裡面來了
是也就是說當我這個t 到這邊
如果我們在這裡我們說是這邊是我的word v
這邊是我的v word v word v
走完的時候呢
是在t 的時候
我我這個這個最後這個state呢就是我的final state
所以這個state呢 就是q f 的v
那麼這個時候呢
我增加一個空的state 是 q
所以這邊我有一個空的state 是q
我仍然在時間t 的時候就給它走過來
ok 我在時間t 的時候我讓它
在這個空的state 裡面然後開始要往下接
那這個時候我就是在在這個呃時間t 從q 開始要走這個word w 了
那麼這個時候呢我這分數怎麼算
我先算我時間同樣的時間t
是我同樣的時間t 走到v 的final state 之後
當時的分數
然後現在要加language model 的分數
那麼這裡其實在這個寫錯了這要改一下喔
這個language model 分數你我們這邊是假設就是只假設language model 我們做bi gram 就好
其實那tri gram 更複雜啦喔
你想一想就知道tri gram 是怎樣的
不過我們現在只講bi gram
bi gram 的話呢這個很直覺的以為是這個
因為我現在v 後面要接w 嘛
所以我現在就是given 這個 v 後面接w 有個bi gram
其實這個寫錯了
我們應該是要看前面的
也就是前面的這一個
這個是u
如果是這樣的話呢那個機率應該是
probability 的這個v given u
是u 後面接v 的bi gram
不是 v 後面接w 的bi gram
這寫錯了喔
為什麼
因為其實你走到這邊為止的時候
你只知道我這條路上到這邊是v 而已
我後面w 還不知道了還沒開始走
所以w 有六萬個可能
這邊有六萬個可能的w
那你不可能把這六萬個bi gram 統統加上來
那就變成有六萬個分數了這不太可能的
所以這裡其實你不太可能知道那個w 是多少
我w 還沒開始走嘛
w 還沒開始走我我沒有這六萬個word 的不知道是誰我我如果真的要這個機率的話我有六萬個是不可能加
的而是應該是走到這邊走完的時候v 知道了
因為我走到最後才知道是哪一個word 嘛
我一路在找
一路在找這個最佳的path 對不對
所以我一路走過來走到最後才知道我這個word 是v
當我知道這個word 是v 的時候我可以把這個u 後面接v 的bi gram 加進來喔
所以你剛才在這邊你v 的bi gram 沒有加進來因為我不知道是什麼我我一路找嘛
我一路找不到最後不知道它是哪一個word嘛
所以呢我找到最後的時候才知道它是v
這個時候我是把u 後面的v 加進來
ok 所以這個地方是應該是這個u 後面接v
是這個的bi gram
不是v 後面接w 的bi gram
ok 那這個意思是什麼
這個意思跟剛才這邊是一樣的
也就是說我們剛才是說我從這邊過來
它可以從前面一個時間可以可以從任何地方過來
那我這邊其實也是一樣
你可以想成我在時間t 的時候其實這邊有六萬個word
我這個一路散開來的時候
在時間t 走完的時候其實有譬如說有三百個word
我這邊有一個v one
這邊有一個v two
那這邊有一個v 三
v one v two v 三都在這個時間t 的時候結束
它們都可以跳到這個q
你可以想是這樣ok
那也就是說我們這個圖現在已經不夠畫了
這個圖現在不夠畫了因為我其實這個不是一個 one d 的
這邊是我們這邊所畫的這個tree 嘛
這邊是一個tree 的結構你長上去的時候很多啦
所以呢當你到這邊的時候
這邊譬如說你在時間t 結束的時間t 所結束的word
其實有v one v 不是只有一個v
有v one v two v 三
都在最後結束分數都在分別是在它那個path 裡面最高的
那它們都在時間t 結束
所以呢我這邊其實有有好幾個
有好幾個
那這個v one v two v 三都在時間t 的時候結束
那因此我現在要跳到這個q 來
準備接下一個word 的時候呢
我可以有好多個可以從這個跳過去也可以從這個跳過去也可以從這個跳過去
那麼因此呢我先要看它是從哪一個v 跳過來的
那就是這件事
那精神跟這邊講的是完全一樣嘛
我現在只是說是要看它是從這個word
還是從v one v two v 三的哪一個的的最後的那個final state
會跳到這個q
來它的分數才是最高的
所以呢我就分別把所有的這些我這邊有六萬個word 在這邊結束
那有的早一點有的晚一點
你可以假設在這個時間t 的時候
有三百個word 在這邊結束
在 t 加一呢又有五百個word 在這邊結束了
t 加二又有一千個word 在這邊結束等等都可能
那麼因此呢你在每一個時間都在做這件事
就是whenever 你的word 走完的時候
你word 走完的時候
你就把那個 language model 那個的word 加進bi gram 加進去之後
然後我要看到底是哪一個word
會跳到那個q 分數是最高的
我就選那一個
那這個精神跟這邊是完全一樣的喔
所以呢我現在就是每一個v 走完的時候的分數
加上那個v 接在那個前面的 u 後面的language model 分數加進去
然後看誰的v 最大
我就從那個跳過去
那麼因此呢我這樣就得到這個那這個是相對於這個
只不過我現在是從是從這個h m m 跳到下一個h m m
或者說從這個tree
跳到下一個tree 的時候的的這個
跟剛才是在裡面走不同的地方在這裡而已
那這樣子我知道是誰最大之後呢我也一樣在這裡
我把那個最大的記下來
所以就把剛才那個maximum
所以這個也寫錯了喔
這個也是應該是這個應該也是這個u 後面接v 的bi gram
這個也是寫錯了
就把剛才這個maximum 誰最大記下來
最大的那個就是我的前一個對不對
所以呢如果是這個v bar 才是最大的
我們現在v one v two v 三
都都在這邊結束後我現在看到的這個
是看到現在是最大是這個
那麼因此我就應該把它的最後最後state 接記記下來
所以我就知道它是從這樣過來的
於是我現在就知道ok 它是從這樣過來的
於是它是從這樣過來的
於是呢我後面開始接下一個tree
那麼因此我現在就把它的這個v bar記下來
做為我的所以我的那個v bar 的最後那個state
就做為我的這個back point
back 這個back track pointer
那麼於是呢那就這這是兩種transition
只要這兩種繼續操作
那我就可以一路走下去

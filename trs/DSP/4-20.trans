這是所謂的 k  means 的 algorithm
這個方法簡單而容易了解
它有一個很大的缺點就是不容易真的用
為什麼呢因為這個嗯我沒有寫在這裡
這邊只是說你可以你有一個夠多的 data 就可以跑了
那麼它一個最大的問題是在我們下一頁講的就是說呢
這跟我們剛才上面講的那個問題一樣
它 converge  to  local  optimum
而且它 depends  on  initial  condition
它的 solution 顯然不是 unique
也就是說你一開始的我們說一開始是你要設幾個代表值的點然後才開始跑嘛
看你那個設的好不好
你設的不一樣跑的結果就是不一樣你的那個 solution 不是 unique 
solution 不是 unique 然後它會看你 initial  condition 設的好不好就不一樣
你很可能會收斂到 local  optimum 去
就跟我們剛剛說的情形是一樣的你現在是要往下走
但是你不見得走到這來
你如果從這開始的話你就停在這裡就出不去了
你如果從這開始你還是停在這裡
必須要從這開始才會到這來
那麼這個是剛才那個演算法的缺點
那麼到後來有人想到一個辦法
這是真正vector  quantization 後來變成有用是有了這個
那這也是它最早最成功的一個演算法所謂的 L B G  algorithm
那麼 L B G 是什麼東西呢是三個人的名字
actually 這是 L 跟 B 是兩個研究生 G 是他們的指導教授
那麼他們三個人他們三個人發明的
那麼這個 L B G 的意思是怎樣呢
我們簡單地解釋就是它變成 iteration
然後呢每一個 iteration 重新來一次
那麼我們可以簡單地來看的話就變成這樣子
它就是說我們仍然以這個為例
我第一次的時候呢我只要 l 等於一
第一次我只要 l 等於一
所以也就是我只要求一個 vector 的 v q 那就是求它的 mean
所以呢我就是找出一個這邊的 mean 來譬如說 mean 在這裡
這是它的 mean 這就是我的第一步我只要等於一就好了
然後第二步我把它 split 變成二
由 l  split 變成二 l
我怎麼 split 呢就是從這個這個當初找到那個核那個代表值開始把它拆成兩個
這最常用的拆法就是這個方法
就是一個向一個一加 epsilon 一個一減 epsilon 這個 epsilon 是一個比一小很多的值
讓它讓它呢在這個核心的附近拆開來變成兩個
譬如說呢我就把這個拆掉變成一個在這裡一個在這裡
不過這兩個仍然非常接近核心
我就從這兩個開始跑
那麼這兩個開始跑這時候跑什麼呢就是跑 k  means 跑剛才那個 k  means
那麼於是呢它就會開始把譬如說把它這個切開來
這樣子然後呢這一堆呢重新求它的 mean 就會跑到這邊來
這堆重新求它的 mean 就會跑到這邊來
OK 那這樣之後呢我再跑 L B G 再來一次
於是呢這個時候我的新的 boundary 到這來了
然後呢我可以再來一次
那麼發現呢是這個比較好這發現是這個比較好等等
當我 l 等於二完成之後就會得到一個比較好的
這個 point 在哪裡呢你可以看到
他剛才這個辦法是他從核從一個整個的中心那裡拆成兩個還在附近
所以基本上它還在中心的部分這兩個都在中心從中心部分開始往外走
那根據它的 data 的分部的情形走到外面來
這樣的話大概這個這個 initial  condition 比較好
那麼這樣子之後呢
我就可以如果我覺得不夠我就再來一次
所以當我這個跑完之後我可以再回到 step  two
我再把 l 分成二 l 　
譬如說我這個可以再拆成兩個
這個再拆成兩個這個也再拆成兩個
然後讓它們再去跑
那麼再去跑的結果呢它就會把這個拆開來
於是這個往這邊跑這個往這邊跑
這個拆開來這個往這邊跑這個往這邊跑
那這樣的話它慢慢慢慢跑出來我的就會接近比較好的
所以這個比較會 converge  to  better  code  book
那這個精神我想很容易想像就是它為什麼會這樣就是我原來的 k  means 裡面太 depends  on  local  optimum
那麼這個時候 depends  on 你的太 depends  on 你的 initial  condition 了
所以呢很會收斂到 local  optimum 去
那用這個方法的話我等於是我先從一個核心開始
從它向旁邊一點走的話呢我慢慢再往外散
這樣的話它比較不至於會搞不好然後它大概都會接近它的 optimum  solution
那我們可以舉一個例子來來解釋
假設有一堆 data 長得很奇怪如我們剛才所說它專門長成這樣
那如果專門長成這樣你如果一開始的的點放在這裡放在這裡什麼的它就不太容易收斂的很好這個就很難
但是呢我如果是用這個方法的話呢你想我會怎樣
第一次得到的一定是在這裡嘛在中間
那第二次就算是它拆的時候拆到這邊來了
拆到這邊來之後變成一個在這裡一個在這裡
那它很可能會畫的一條線是這樣子的那也沒有關係
這個時候各自去跑 l b g 各自去跑 k  means 之後那它會怎樣
那它顯然會往這邊搬它顯然會往這邊搬
OK然後它再拆開來就算它再拆錯也沒有關係
它再拆成一個這樣子一個這樣子的話呢它最後還是會它最後還是會它往這邊搬它往這邊搬
它最後一定會它往這邊搬它往這邊搬
所以最後呢它們會得到一個比較好的 code  book
那這個是這個把它由核心去拆成兩個的一個辦法
當然還有另外一個辦法就是一個用原來的一個用最遠的也可以
那如果一個用原來的一個用最遠的話呢這個意思是像這樣
我們也舉個例子譬如說我的 data 也是這樣子的
我得到一個在這裡
那我現在怎麼辦我的兩個呢一個就用這個另外一個用最遠的
這個時候跟它最遠是在這裡 OK 我就在這裡
如果就在這裡的話呢我一開始就會切在這裡這個歸它這個歸它
但是之後我再來繼續跑這個 k  means 的話呢它就會往這邊搬
於是呢這個就會往這邊搬它就會往這邊搬對不對
於是你就會看到這個會向這邊移動這個也會向這邊移動這個也會向這邊移動所以它慢慢就會過來
那這樣也是可以的所以這是另外一招
不過這精神都一樣就是用這個方法來得到的就是這個就是這個喔這是 l b g  algorithm
那這個呢到這裡我們 v q 講到這裡
那麼我們可以回過頭來看剛才第二句話
我們在這裡做 v q 不是為了剛才講的 data  compression 是為了拿來做 clustering  large  number  of  sample  vectors
當我有一大堆 vector 的時候倒底怎麼樣把它們分成最合理的一群一群
然後每一個群分別有最有代表性的 vector
那等於是這件事情那我們很多時候做 vector  quantization 是這個目的
那這樣的話就像我們這裡其實是這個目的然後可以做這樣的事
好有了這個之後我們現在底下就可以講我這個 v q 怎麼拿來做這個 HMM 的 initialization
那就是底下這一段 OK 我們休息十分鐘
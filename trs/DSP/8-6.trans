ok 一路走下去是可以
不過這個這個還是大的不得了
所以我們要有一些辦法來簡化它
有很多種方法來簡化它因為現在這個search 你可以想像非常大
這是我們所謂的search
那怎麼簡化它呢一個最簡單的辦法就是所謂的beam search
beam search 意思是說在每一個時間t 我只保留一個sub set
of 最可能的path
其它都丟掉
你可以想像我從一開始走
它很快就長很多很多很多
長那麼多之後你簡直沒辦法處理
所以呢最簡單的辦法就是做beam search
舉例來講define 一個beam width l
我們通當講譬如l 是三百或者六百或者二百
也就是說我我我很快走過來這邊就很多很多了
那我就只保留分數最高的
那二百個還是六百個path
其它全部丟掉
那我一路走的時候呢我一路在算分數最高的那個path
之後我保留六百個譬如說
其它全部丟掉
那這樣我才有辦法往前走
那當然如果這樣走的話就表示這不是已經不是一個optimum 的了
喔這又是一個喔這又是一個是個approximation
因為你可以想像
分數最高的path 不見得從頭到尾一定分數最高嘛喔
這個龜兔賽跑的原理嘛
期中考考最好的人期末考不一定最好嘛
所以你如果一開始就把ok 期中考裡面考最好的十個人留下來其它通通殺掉的話
那到最後其實可能最好的被你殺掉了對不對
這裡也是一樣的
你這個這個一路跑過來的時候
所以你的這個這個beam width 如果保留的越大是比較好
但是你的計計算量立刻就會大很多嘛
所以這個就是怎麼選擇這個問題
通常我們兩種簡單的辦法
一種是保留一個就定義一個beam width
譬如說你就是每在每一個時間點t 上面
我永遠只keep 前六百名或前三百名
等等那這樣的話讓我的計算量不會太大
第二種我就定義一個threshold
凡是的我分數比最高分少那個threshold 之內的我都保留
不管多少個
那有的時候這裡有一百個有的時候這裡有一千個
我反正是是這個在這個threshold 之內的我都保留喔
這兩種基本上這都是我保留一個beam
然後呢我就在beam 裡面走
那我自然就已經把可能的optimum 丟掉是可能的
所以你這樣子得到不見得是最佳的
但是是接近就是了
那這是最簡單最常用的這個reducing search space 的方法
當然還有很多進一步的方法我想我們這邊就不說
你如果有興趣去看讀相關的reference 就會覺得講很多種方法
因為這個其實是一個關鍵性的問題那麼有一堆研究如何做
那麼一個例子就是ok 你也可以從acoustic model 從acoustic 的h m m 的分數裡面去看
哪一些地方h m m 看起來它比較好比較不好把它丟掉
從language model 來看
那麼哪些應該丟掉什麼這這都有
那麼另外一個非常標準的做法就是所謂的multi pass 的search
也就是說我至少分成兩個pass
那這個意思是什麼呢
就是說喔應該是講說我在我先有第一個path
用比較簡單的knowledge
簡單的constraint
我就得到一個比較簡單的比較小的search space
在第二個裡面再做複雜的
嗯這話怎麼講呢
最簡單的想法就是說譬如說tri phone
tri phone 太複雜了
我前面就只做一mono phone
我我我一開始我我我不要做那個
我不要那這裡面我tree我這個lexicon 也可以有兩種嘛
一種是phone 的
一種是tri phone 的
tri phone 數目多很多所以會複雜
我就我先不要用tri phone 我就先用這個單獨的phone 做
那這樣就比較簡單
我就可以做第一個pass
或者譬如說這個language model 那裡呢
你可以想像我們這邊只講bi gram
是因為tri gram 複雜哦
我如果tri gram 的話
我走到這裡的時候
我不但要把這個bi gram 加進來
還要把這個tri gram 加進來
那我每一次都要都要再再算一個bi gram 算一個tri gram 是會複雜
那我也可以說我在我在第一個path 的時候我只做bi gram
後面呢才做tri gram
或者說我甚至於language model 我在前面不做
我我 language model 到後面才做等等
那因此呢我的第一個path
就可以比較簡單一點
那第一個path 的的出來結果呢
我們把它做成一個word graph
或者一個n best list
什麼意思呢
所謂的一個word graph 就是所有可能的word
可能性比較高的分數比較高的word
把它的時間點通通記下來
就構成一個 word graph
這是時間點
所以呢它譬如說譬如說到這個時間為止
從這一點到這一點
是可能是w one 是某一個word
到這一點也可能是 w two 是這個word
那這邊呢可能有另外一個word 是w 三
那這邊可能有另外一個word 是w 四
那這邊可能有另外一個word 是w 五
這可能有另外一個word w 六
那這邊可能有另外一個word 是w 七
ok 所以呢我從這個時間點到這個時間點的話呢
我可能是這樣子
這個可能是w word w one 這個可能是w two
它也許是w two 的前面一半喔
那那它也許到w two 也許不是對也許是w 四的前面一半喔等等
那麼因此我就把所有可能的word 它的時間點的起點終點通通記下來
它就可以構成一個graph
那這個graph 呢其實你給我一句話我可以先把這個graph
找出來當我這個graph 找出來之後呢
那其實它告訴我我現在只要在這上面找就好了
它 either 是一三五
或者是二五
或者是一六
或者是四七等等
那搞不好這邊還有一個
譬如說這可能也是一個
這個w 八
於是也可能是一三八七對不對
那麼因此呢你就在這裡面去看喔
那麼如果這樣的意思是說我的第一個pass
基本上做法還是跟剛才一樣這樣子做
但是呢我我只用比較簡單的東西
譬如說我只用這個這個我不要用tri phone 我只用單獨的一個phone
我不要用tri gram 我只用 bi gram
什麼的話
我也可以這樣走
這個程式稍微簡單一點然後我就取最可能的分數最高的word
哪裡是可能分數最高的word
那你可以想像因為我現在六萬個word
有的早一點結束有的晚一點結束
有的早結束有的晚結束就是我們這邊所畫的就是
譬如說w one 在這邊就結束了
w two 到這邊才結束
w 四要到這兒才結束對不對
我就把這裡面分數最高的word 保留下來
就構成一個 word graph
那麼這個東西我底下就只要在這上面算就好了
那麼因此呢我這個複雜的東西
在後面算
那麼我這個時候我這個再把複雜的
那也等於是說我我這個很複雜的這個這個tree 後面接這麼多tree 後面接這麼那這個東西呢我就把它reduce 成為變成只有那樣子
不但是變成只有那樣子而且它不會發散
而是最後會reduce 到一點
不一定是一點啦你這邊可能也有也有不只一個
但是譬如說這邊還有一個w 九
但是基本上你不不會一直這樣越長越大越長越大
你你你可以限制它就這麼大
ok 於是呢我真正的複雜的tri gram 啦
或者tri phone 啦什麼這個複雜的東西
我只在這上面算
那這個search space
比原來那個要小很多很多那個太大了
那個大到無法算所以我就先我先用一些簡單的就是less knowledge 或者less constraint
用一些簡單的辦法
把那個大的tree
那個太大的那個那個那個 tree
reduce 到變成一個小的graph
然後呢我現在把這個東西
在這上面才做詳細的
那這是我們通常稱為re scoring
你現在再把你的詳細的你的tri gram tri phone
分數詳細去算
那剛才因為只用簡單的所以你那個分數不太對
我現在可以把詳細重算一次分數
所以叫做re scoring
那之後呢你可能會發現這上面雖然有這麼多種可能
其實最可能的是這條
譬如說是w two 接w 八接w 九
可能這條才是你的答案譬如說這樣子
那你就可以在 word graph 上面找出來
那這是所謂的multi pass search 的基本觀念
那當然這樣做的時候基本上你前面的這塊第一個path
所謂的這個word graph generation
其實跟那剛才那個是一樣的
只是簡單一點
我用比較簡單的knowledge 用比較簡單的constraint
譬如說我只用我我不要用tri phone 我不要用tri gram
等等我簡單一點就其實是一樣的
然後我就是保留最重要分數最高的word
譬如說在這個時間點結束是以它最高
或者你也可以再保留一個啦對不對你可以再保留
你保留若干個這個時間點結束的分數最高的
然後你在這個時間點你把它保留你這樣一路這樣你會得到一堆
那你就把它們構成一個graph
那如果是這樣子的話很可能我們可以把它畫成
這樣子這是w 十
那它們都n end 都在同一點
然後後面都可以接這些等等
那這就是所謂的 word graph
那你有了word graph 之後在word graph 上面
再用比較詳細的再重跑一次
re score 這些所有的path 之後
你算哪一條path 分數最高等等
那這是這個所謂用word graph 的方法
那麼n best list 是相同的意思
只是說呢它沒有做成這樣子的word graph
而是直接把前一百名譬如說這個n best 就是n 就是這個這個前n 個名次分數最高的word list
全部把它保留下來
那麼舉例來講在這個case 的話你就可能
就這個case 的話你可能想像的就是譬如說
一三五這是一個
w 一 w 三 w 五
這是一個一三五
那麼二二五也是一個w 二 w 五這也是一個
那麼w 四九也是一個喔等等等等
那你如果沒有把這個word graph 建起來
只是說把分數最高的一些word 的word sequence 把它通通都留下來
譬如保留前一百名或者保留前二百名或者前五十名
那就所謂的這個n 等於一百或者五十或者二百的 n best
那你就把這個list 留下來之後我重新在這上面算分數
那你可以想像這兩種那一個好呢
這個是比較精簡啦
這個可以把它們這個其實包含的東西比這個還豐富
這個只告訴我說一後面接三三後面接五
那這個其實告訴我說
一是在什麼時候結束
三在什麼時候開始
三是在什麼時候結束後面五等等
所以呢我我其實三後面還可以接八接九什麼
它都都在這邊都呈現了
所以這是一個比較精簡的描述的方法
你這樣保留一個這個word graph 的效果
會比這個好
但是這個簡單
你這個這個呢你就是把剛才一路找過來的你第一個path 也是用比較簡單的方法來做
但是我一路走過來之後我就把前一百名留下來
得到一個一百的list 喔
那這就是所謂的n best list
那這兩種方法都可以
我這上面舉的這兩個例子在說明這個這個n best list
是不如這個 word graph 來的有效喔
那像這個例子呢你常常前幾名是只差一點點
i’ll tell you what i think 還是 why i think 還是when i think
只是這個地方不對不曉得是哪一個
其它都一樣
那你如果是做保留這個n best list
就會發現常常譬如說前五名
都一樣只差一個字
那你保留這個呢你全部重算有點浪費嘛
其實你應該把它變成一個word graph
那這邊都一樣只有這個地方不同
對不對只有最後這個地方不同
那這樣子的話你的這個嗯比較有效的使用空間跟這個資訊
那所以呢這個這個這個是
word graph 這是n best list
那不管怎樣你都是這樣
所以呢我的真正的效果呢就是
我de cup 這個de couple 本來的這個複雜的search problem into a simpler process
對不對就是說我我現在就是把我整個的做的話這個太複雜了
所以呢我可以把它拆成兩半
第一半用比較簡單的東西
the first primary by acoustic scores
或者是the second by language 這也是一種辦法
我language 在在第二個做哦等等
或者這個是一個例子
這底下也是一個例子
那基本上我就是把它 de couple 成為兩個stage
或者可以更多
所謂的multi pass 不一定兩個啦你還可以第三個啦
你可以在在這邊之後
我還不做決定
我在這邊之後呢我可以這個弄一個比較複雜的word graph
在這邊再做一次re scoring 把它簡化成一個再簡單一點的再做第三次也可以哦看你要怎麼做
所以你可以分成不只一個path
那這樣的話呢就每一個path 都比較簡單
那我的search space 只有在第一個的時候很大
後面就算動縮小
縮小之後
我再做精緻的
那這是一個常用的方法好
